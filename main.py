from dataclasses import dataclass
from hashlib import sha256
from typing import Union

# Create an empty chain for blocks to be stored.
chain: list = []

# This is an index which will match block hashes -> the block height (chain index)
chain_hash_index: dict[str, int] = {}

# A real chain also keeps up with this state by height.
balances: dict[str, int] = {}

FEE_ACCOUNT_MODULE = "fee_account_module"


# Base single types
@dataclass
class Coin:
    denom: str
    amount: int


# Messages
@dataclass
class BankSendMsg:
    sender: str
    recipient: str
    amount: Coin

    type: str = "@bank_send"

    # After the block is created successfully (on Tx submit in this mock env)
    # We will call the handler to update the state.
    def handler(self):
        global balances
        current_sender_balance = balances.get(self.sender, 0)
        current_recipient_balance = balances.get(self.recipient, 0)

        if current_sender_balance < self.amount.amount:
            raise Exception("Insufficient funds")

        balances[self.sender] = current_sender_balance - self.amount.amount
        balances[self.recipient] = current_recipient_balance + self.amount.amount


@dataclass
class DelegateStakingMsg:
    delegator: str
    validator: str
    amount: Coin

    type: str = "@delegate_staking"


# All messages
AllMsgTypes = Union[BankSendMsg, DelegateStakingMsg]


class Message:
    msg: AllMsgTypes

    def __init__(self, msg: AllMsgTypes):
        self.msg = msg

    def __repr__(self):
        return f"{self.msg}"


@dataclass
class Tx:
    sender: str
    messages: list[Message]
    fee: Coin
    signature: str = ""

    def __copy__(self):
        return Tx(
            sender=self.sender,
            signature=self.signature,
            messages=self.messages,
            fee=self.fee,
        )

    def sign(self) -> "Tx":
        tmp_tx = self.__copy__()
        tmp_tx.signature = ""

        # sign tmp_tx with sender as a salt to simulate a 'private' key signing for now.
        sign_sha = sha256((str(tmp_tx) + self.sender).encode()).hexdigest()
        self.signature = sign_sha
        return self

    def verify_signature(self) -> bool:
        tmp_tx = self.__copy__()
        tmp_tx.signature = ""

        sign_sha = sha256((str(tmp_tx) + self.sender).encode()).hexdigest()
        return sign_sha == self.signature


@dataclass
class Block:
    hash: str
    height: int
    previous_hash: str
    txs: list[Tx]

    def __copy__(self):
        return Block(
            hash=self.hash,
            height=self.height,
            previous_hash=self.previous_hash,
            txs=self.txs,
        )


def generate_block_hash(block: Block) -> str:
    # hard clone block
    iBlock = block.__copy__()
    # normalize the block hash so we get the same output every time.
    iBlock.hash = ""
    return sha256(str(iBlock).encode()).hexdigest()


def create_new_block(txs: list[Tx] = []) -> Block:
    # height is generated by the length of the chain.
    height = len(chain)
    previous_hash = ""
    if height > 0:
        previous_hash = chain[len(chain) - 1].hash

    for tx in txs:
        if not isinstance(tx, Tx):
            raise Exception("All txs must be of type Tx")
        else:
            # remove fee from their account
            if not tx.verify_signature():
                raise Exception("Invalid signature")

            if tx.sender not in balances:
                balances[tx.sender] = 0

            if balances[tx.sender] < (tx.fee).amount:
                raise Exception("Insufficient funds for fee")

            balances[tx.sender] -= (tx.fee).amount
            balances[FEE_ACCOUNT_MODULE] += (tx.fee).amount

            for MSG in tx.messages:
                # check if handler function is defined
                if hasattr(MSG.msg, "handler"):
                    MSG.msg.handler()

    # Create the base block
    block = Block(hash="", height=height, previous_hash=previous_hash, txs=txs)
    # Set the hash of the data for the block after the fact.
    block.hash = generate_block_hash(block)

    # TODO: Add handler here for each message

    return block


def add_to_chain(block):
    global chain
    global chain_index
    chain.append(block)
    chain_hash_index[block.hash] = block.height


def get_block(height: int = 0) -> Block:
    if height > len(chain):
        raise Exception("Block height does not exist")

    return chain[height]


def verify_chain() -> bool:
    # iterate through the chain and ensure that the hashes are correct.
    for block in chain:
        if block.hash != generate_block_hash(block):
            print("Block hash does not match", block.height)
            return False

        # ensure the previous hash is correct
        if block.height > 0:
            previous_block = get_block(block.height - 1)
            if previous_block.hash != block.previous_hash:
                print("Previous hash does not match", block.height)
                return False

    return True


def main():
    # Create a blank initial block to start the chain.
    genesis_block = create_new_block(txs=[])
    # Within the genesis block, we can set the initial state to anything we want.
    balances["Alice"] = 1_000_000
    balances["Bob"] = 5_000
    balances[FEE_ACCOUNT_MODULE] = 0
    # Add the genesis block to the chain.
    add_to_chain(genesis_block)

    # Block 1
    aliceBankMsg = BankSendMsg(
        sender="Alice",
        recipient="Bob",
        amount=Coin(denom="TOKEN", amount=99),
    )

    aliceTx = Tx(
        fee=Coin("TOKEN", 500),
        messages=[Message(aliceBankMsg)],
        sender="Alice",
    ).sign()

    # print(aliceTx, aliceTx.verify_signature())

    add_to_chain(create_new_block(txs=[aliceTx]))

    # Block 2
    bobStaking = DelegateStakingMsg(
        delegator="Bob",
        validator="tokenvaloper1strangelove",
        amount=Coin(denom="TOKEN", amount=100),
    )

    bobTx = Tx(
        sender="Bob",
        fee=Coin("TOKEN", 500),
        messages=[Message(bobStaking)],
    ).sign()

    add_to_chain(create_new_block(txs=[bobTx]))

    print(chain)

    print("Chain verified", verify_chain())

    print(balances)

    # modify a block to show verify will fail.
    # chain[1].txs[0].sender = "Someone Else"
    # print("Verify Chain after modification:", verify_chain())


if __name__ == "__main__":
    main()
